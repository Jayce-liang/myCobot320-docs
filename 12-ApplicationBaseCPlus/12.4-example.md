## 关节控制

**在这个案例下，首先接通机器电源，然后读取当前角度。然后，在单关节角度控制和多关节角度控制中读取关节 1 的最小角度和最大角度，然后在点动运动中执行指定的关节运动、绝对位置点运动和增量位置点运动。上述所有运动都将打印运动信息。**

    ```c++
    int main(int argc, char* argv[]) {
        try {
            QCoreApplication a(argc, argv);
            using namespace std::chrono_literals;

            if (!mycobot::MyCobot::I().IsControllerConnected()) {
                std::cerr << "Robot is not connected\n";
                exit(EXIT_FAILURE);
            }

            std::cout << "Robot is connected\n";
            mycobot::MyCobot::I().PowerOn(); // 打开机器电源
            mycobot::MyCobot::I().StopRobot(); // 关闭机器
            std::cout << "Robot is moving: " << mycobot::MyCobot::I().IsMoving() << "\n"; // 检查机器是否在运动

            mycobot::Angles angles = mycobot::MyCobot::I().GetAngles(); // 获取机器的当前角度
            std::this_thread::sleep_for(200ms);
            mycobot::Coords coords = mycobot::MyCobot::I().GetCoords(); // 获取机器的当前坐标
            angles = mycobot::MyCobot::I().GetAngles(); // 获取机器的当前角度
            std::cout << "[" << angles[mycobot::J1] << ", " << angles[mycobot::J2] << ", " << angles[mycobot::J3] << ", "
                    << angles[mycobot::J4] << ", " << angles[mycobot::J5] << ", " << angles[mycobot::J6] << "]";

            mycobot::MyCobot::I().WriteAngle(mycobot::Joint::J1, 10, 30); // 发送单关节角度

            while (mycobot::MyCobot::I().IsMoving()) { // 检查机器是否已到达目标角度
                angles = mycobot::MyCobot::I().GetAngles();
                std::cout << "Current joint angles" << "[" << angles[mycobot::J1] << ", " << angles[mycobot::J2] << ", "
                        << angles[mycobot::J3] << ", " << angles[mycobot::J4] << ", "
                        << angles[mycobot::J5] << ", " << angles[mycobot::J6] << "]" << std::flush;
                std::this_thread::sleep_for(200ms);
            }


            mycobot::Angles goal_angles = { 5, 5, 5, 5, 5, 5 }; // 定义一组角度
            mycobot::MyCobot::I().WriteAngles(goal_angles); // 发送关节角度

            while (mycobot::MyCobot::I().IsMoving()) { // 检查机器是否已到达角度
                angles = mycobot::MyCobot::I().GetAngles();
                std::cout << "Current angles" << "[" << angles[mycobot::J1] << ", " << angles[mycobot::J2] << ", "
                        << angles[mycobot::J3] << ", " << angles[mycobot::J4] << ", "
                        << angles[mycobot::J5] << ", " << angles[mycobot::J6] << "]" << std::flush;
                std::this_thread::sleep_for(200ms);
            }


            mycobot::MyCobot::I().GetJointMin(mycobot::Joint::J1); // 读取最小关节角度
            std::cout << "Current joint angle" << "[" << angles[mycobot::J1]  << "]" << std::flush;
            std::this_thread::sleep_for(200ms);

            mycobot::MyCobot::I().GetJointMax(mycobot::Joint::J1); // 读取最大关节角度
            std::cout << "Current joint angle" << "[" << angles[mycobot::J1]  << "]" << std::flush;
            std::this_thread::sleep_for(200ms);

            // 在指定关节上做点动运动
            mycobot::MyCobot::I().JogAngle((mycobot::Joint)0, 100, 5);
            std::this_thread::sleep_for(200ms);
            while (mycobot::MyCobot::I().IsMoving()) { // 检查运动是否已完成
                angles = mycobot::MyCobot::I().GetAngles();
                std::cout << "Performing specified motion, current angle of joint 1" << "[" << angles[mycobot::J1] << "]"
                        << std::flush;
                std::this_thread::sleep_for(200ms);
            }


            // 在指定关节上进行位置递增的点动运动
            mycobot::MyCobot::I().JogAngleIncrement((mycobot::Joint)0, 5, 180);
            std::this_thread::sleep_for(200ms);

            while (mycobot::MyCobot::I().IsMoving()) { // 检查运动是否已完成
                angles = mycobot::MyCobot::I().GetAngles();
                std::cout << "Performing incremental motion, current angle of joint 1" << "[" << angles[mycobot::J1] << "]"
                        << std::flush;
                std::this_thread::sleep_for(200ms);
            }

            std::this_thread::sleep_for(5000ms); // 延迟功能
            mycobot::MyCobot::I().StopRobot(); // 停止机器

            std::cout << "\n";
            exit(EXIT_SUCCESS); // 成功退出
        } catch (std::error_code&) {
            std::cerr << "System error. Exiting.\n";
            exit(EXIT_FAILURE);
        } catch (...) {
            std::cerr << "Unknown exception thrown. Exiting.\n";
            exit(EXIT_FAILURE);
        }

        return 0;
    }
    ```

## 协调控制

**在这个案例下，首先接通机器电源，然后读取当前坐标。然后执行单坐标控制和多坐标控制，再执行点动运动中的指定关节坐标运动、绝对位置坐标点运动和增量位置坐标点运动。上述所有运动都将打印运动信息。**

    ```C++
    int main(int argc, char* argv[]) {
        try {
            QCoreApplication a(argc, argv);
            using namespace std::chrono_literals;

            if (!mycobot::MyCobot::I().IsControllerConnected()) {
                std::cerr << "Robot is not connected\n";
                exit(EXIT_FAILURE);
            }

            std::cout << "Robot is connected\n";
            mycobot::MyCobot::I().PowerOn(); // 打开机器电源
            mycobot::MyCobot::I().StopRobot(); // 停止机器
            std::cout << "Robot is moving: " << mycobot::MyCobot::I().IsMoving() << "\n";
            mycobot::Angles angles = mycobot::MyCobot::I().GetAngles(); // 获取当前关节角度
            std::this_thread::sleep_for(200ms);
            mycobot::Coords coords = mycobot::MyCobot::I().GetCoords(); // 获取当前坐标
            std::cout << "Coordinates before motion" << "[" << coords[mycobot::Axis::X] << ", " << coords[mycobot::Axis::Y] << ", " << coords[mycobot::Axis::Z] << ", "
                << coords[mycobot::Axis::RX] << ", " << coords[mycobot::Axis::RY] << ", " << coords[mycobot::Axis::RZ] << "]";

            // 发送单参数坐标
            mycobot::Coords goal_coords = { 90, 0, 0, 0, 0, 0 }; // 定义目标坐标
            mycobot::MyCobot::I().WriteCoord(mycobot::Axis::X, 90, 180); // 发送目标坐标
            while (!mycobot::MyCobot::I().IsInPosition(goal_coords, false)) {
                coords = mycobot::MyCobot::I().GetCoords(); // 获取当前坐标
                std::cout << "Coordinates after single-parameter motion" << "[" << coords[mycobot::Axis::X] << ", " << coords[mycobot::Axis::Y] << ", "
                    << coords[mycobot::Axis::Z] << ", " << coords[mycobot::Axis::RX] << ", "
                    << coords[mycobot::Axis::RY] << ", " << coords[mycobot::Axis::RZ] << "]" << std::flush;
                std::this_thread::sleep_for(200ms);
            }

            // 发送所有坐标
            goal_coords = { 100, 100, 0, 0, 0, 0 }; // 定义目标坐标
            mycobot::MyCobot::I().WriteCoords(goal_coords, 30);
            while (!mycobot::MyCobot::I().IsInPosition(goal_coords, false)) {
                coords = mycobot::MyCobot::I().GetCoords(); // 获取当前坐标
                std::cout << "Coordinates after all-coordinates motion" << "[" << coords[mycobot::Axis::X] << ", " << coords[mycobot::Axis::Y] << ", "
                    << coords[mycobot::Axis::Z] << ", " << coords[mycobot::Axis::RX] << ", "
                    << coords[mycobot::Axis::RY] << ", " << coords[mycobot::Axis::RZ] << "]" << std::flush;
                std::this_thread::sleep_for(200ms);
            }

            // 在指定坐标轴上做点动运动
            mycobot::MyCobot::I().JogCoord(mycobot::Axis::X, 1, 30);
            while (mycobot::MyCobot::I().IsMoving()) {
                coords = mycobot::MyCobot::I().GetCoords(); // 获取当前坐标
                std::cout << "Coordinates after jogging on specified axis" << "[" << coords[mycobot::Axis::X] << ", " << coords[mycobot::Axis::Y] << ", "
                    << coords[mycobot::Axis::Z] << ", " << coords[mycobot::Axis::RX] << ", "
                    << coords[mycobot::Axis::RY] << ", " << coords[mycobot::Axis::RZ] << "]" << std::flush;
                std::this_thread::sleep_for(200ms);
            }

            // 在指定坐标轴上进行位置递增的点动运动
            mycobot::MyCobot::I().JogCoordIncrement(mycobot::Axis::X, 30, 30);
            while (mycobot::MyCobot::I().IsMoving()) {
                coords = mycobot::MyCobot::I().GetCoords(); // 获取当前坐标
                std::cout << "Coordinates after incremental jogging on specified axis" << "[" << coords[mycobot::Axis::X] << ", " << coords[mycobot::Axis::Y] << ", "
                    << coords[mycobot::Axis::Z] << ", " << coords[mycobot::Axis::RX] << ", "
                    << coords[mycobot::Axis::RY] << ", " << coords[mycobot::Axis::RZ] << "]" << std::flush;
                std::this_thread::sleep_for(200ms);
            }

            mycobot::MyCobot::I().JogAngle(mycobot::Joint::J1, 1, 5);
            std::this_thread::sleep_for(5000ms);
            mycobot::MyCobot::I().StopRobot();

            std::cout << "\n";
            exit(EXIT_SUCCESS);
        } catch (std::error_code&) {
            std::cerr << "System error. Exiting.\n";
            exit(EXIT_FAILURE);
        } catch (...) {
            std::cerr << "Unknown exception thrown. Exiting.\n";
            exit(EXIT_FAILURE);
        }

        return 0;
    }
    ```

## IO 控制

**在本示例中，首先打开机器电源，设置 io 输出，2、5、26 为 m5 输出引脚，35、36 为 m5 输入引脚，原子输出引脚 23、33 输出高电平，并读取原子输入引脚 22、19 的电平信息。**

    ```C++
    int main(int argc, char* argv[])
    {
    	try {
    		QCoreApplication a(argc, argv);
    		using namespace std::chrono_literals;
    		if (!mycobot::MyCobot::I().IsControllerConnected()) {
    			std::cerr << "Robot is not connected\n";
    			exit(EXIT_FAILURE);
    	}
    	std::cout << "Robot is connected\n";
    	mycobot::MyCobot::I().PowerOn();
    	mycobot::MyCobot::I().SleepSecond(1);

    	mycobot::MyCobot::I().SetBasicOut(2, 1);
    	mycobot::MyCobot::I().SleepSecond(1);
    	mycobot::MyCobot::I().SetBasicOut(5, 1);
    	mycobot::MyCobot::I().SleepSecond(1);
    	mycobot::MyCobot::I().SetBasicOut(26, 1);
    	mycobot::MyCobot::I().SleepSecond(1);

    	for (int i = 0; i < 2; i++) {
    		std::cout << "35= " << mycobot::MyCobot::I().GetBasicIn(35) << std::endl;
    		mycobot::MyCobot::I().SleepSecond(1);
    		std::cout << "36= " << mycobot::MyCobot::I().GetBasicIn(36) << std::endl;
    		mycobot::MyCobot::I().SleepSecond(1);
    	}

    	/*mycobot::MyCobot::I().SetDigitalOut(23, 1);
    	mycobot::MyCobot::I().SleepSecond(1);
    	mycobot::MyCobot::I().SetDigitalOut(33, 1);
    	mycobot::MyCobot::I().SleepSecond(1);*/

    	for (int i = 0; i < 2; i++) {
    		std::cout << "22= " << mycobot::MyCobot::I().GetDigitalIn(22) << std::endl;
    		mycobot::MyCobot::I().SleepSecond(1);
    		std::cout << "19= " << mycobot::MyCobot::I().GetDigitalIn(19) << std::endl;
    		mycobot::MyCobot::I().SleepSecond(1);
    	}

    	mycobot::MyCobot::I().StopRobot();
    	std::cout << "Robot is moving: " << mycobot::MyCobot::I
    	std::this_thread::sleep_for(5000ms);
    	mycobot::MyCobot::I().StopRobot();

    	std::cout << "\n";
    	exit(EXIT_SUCCESS);
    	} catch (std::error_code&) {
    	std::cerr << "System error. Exiting.\n";
    	exit(EXIT_FAILURE);
    	} catch (...) {
    	std::cerr << "Unknown exception thrown. Exiting.\n";
    	exit(EXIT_FAILURE);
    	}
    }
    ```

---

[← 上一页](12.3-API.md) | [下一页 →](../15-ApplicationBaseCSharp/README.md)
